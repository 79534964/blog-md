---

title: 适配器模式
date: 2018-11-06
categories: 架构
tags: 设计模式

---

## 介绍
** 1.  旧接口格式和使用者不兼容 **
** 2.  中间加一个适配转换接口 **

## 示例
[![适配器插座](http://118.24.216.136:80/blog/img/2018-11-06/d6a7038cc1b1e0adfcdc9881f08d623.png "适配器插座")](http://118.24.216.136:80/blog/img/2018-11-06/d6a7038cc1b1e0adfcdc9881f08d623.png "适配器插座")

## 代码演示

## javascript

```javascript
class Adaptee {
	specificRequest() {
		return '德国标准的插头';
	}
};

class Target {
	constructor() {
		this.adaptee = new Adaptee();
	}
	request() {
		let info = this.adaptee.specificRequest();
		return `${info} -> 转换器 -> 中医标准的插头`;
	}
};

let target = new Target();
target.request();
```

## java

```java
// 适配者
public class Adaptee {
	public void adapteeRequest() {
		System.out.println('适配者的方法');
	}
}

public interface Target {
	void request();
}

// 被适配的对象
public class ConcreteTarget implements Target {
	@Override
	public void request() {
		System.out.println('被适配的原方法')
	}
}

// 类适配器
public class Adapter extends Adaptee implements Target {
	@Override
	public void request() {
		// 实现被适配的方法 继承适配者，重写被适配的方法，调用适配器的方法
		super.adapteeRequest();
	}
}

// 对象适配器
public class Adapter implements Target {
	// 对象适配器直接new成对象
	private Adaptee adaptee = new Adaptee();
	
	@Override
	public void request() {
		adaptee.adapteeRequest();
	}
}

public class Test {
	public static void main(String[] args) {
		// 原来的对象
		Target target = new ConcreteTarget();
		target.request();
		// 适配器对象
		Target adapterTarget = new Adapter();
		adapterTarget.request();
	}
}

```

## 应用场景
```javascript
// 自己封装的ajax,使用方法如下
ajax({
	url：'/getData',
	type: 'Post',
	dataType: 'json',
	data: {
		id: '123'
	}
}).done(()=>{});

// 因为历史原因，代码中全都是：
// $.ajax({...});

// 做一层适配
var $ = {
	ajax: (options) => {
		return ajax(options);
	}
};
```
vue 中的 ** computed ** 在模板和数据之前做了一层适配

## 设计原则校验
** 1.  将旧接口和使用者进行分离 **
** 2.  符合开放封闭原则 **